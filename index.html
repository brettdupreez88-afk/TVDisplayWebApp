<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TV Display</title>

  <style>
    /* ===== Reset ===== */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    /* ===== Responsive sizing tokens ===== */
    :root{
      --padX: clamp(18px, 3vw, 56px);
      --padY: clamp(18px, 3vw, 56px);
      --gap: clamp(12px, 1.6vw, 28px);
      --radius: clamp(14px, 1.2vw, 24px);

      --titleSize: clamp(28px, 3.2vw, 64px);

      --tilePad: clamp(12px, 1.2vw, 22px);
      --tapLabelSize: clamp(18px, 1.6vw, 34px);

      --tileTitleSize: clamp(18px, 1.7vw, 40px);
      --tileTextSize: clamp(14px, 1.25vw, 30px);

      --imgH: clamp(210px, 34vh, 520px);
    }

    /* ===== Layout ===== */
    .wrap {
      height: 100vh;                /* IMPORTANT: constrain to viewport */
      display: flex;
      flex-direction: column;
    }

    /* Page title */
    .top {
      padding: calc(var(--padY) * 0.7) var(--padX) calc(var(--padY) * 0.4);
      font-size: var(--titleSize);
      font-weight: 800;
      letter-spacing: clamp(0px, 0.05vw, 1px);
      line-height: 1.05;
      text-align: center;
      flex: 0 0 auto;
    }

    /* 3-column grid */
    .grid {
      flex: 1;
      min-height: 0;                /* IMPORTANT */
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-rows: 1fr;      /* IMPORTANT: constrain tile height */
      gap: var(--gap);
      padding: 0 var(--padX) var(--padY);
      align-items: stretch;         /* IMPORTANT */
    }

    /* Tile */
    .tile {
      height: 100%;                 /* IMPORTANT */
      min-height: 0;
      overflow: hidden;             /* IMPORTANT */
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: var(--radius);
      padding: var(--tilePad);
      display: flex;
      flex-direction: column;
    }

    /* Tap label (Tap 1/2/3) */
    .tap-label {
      margin: 0 0 clamp(10px, 1vw, 16px);
      font-size: var(--tapLabelSize);
      font-weight: 800;
      text-align: center;
      line-height: 1.1;
      flex: 0 0 auto;
    }

    /* Image */
    .img {
      width: 100%;
      height: var(--imgH);
      object-fit: cover;
      border-radius: calc(var(--radius) * 0.75);
      margin-bottom: clamp(10px, 0.9vw, 16px);
      display: block;
      flex: 0 0 auto;
    }

    /* Content title (from Title.txt) */
    .tile h2.content-title {
      margin: 0 0 clamp(6px, 0.7vw, 12px);
      font-size: var(--tileTitleSize);
      font-weight: 750;
      line-height: 1.12;
      flex: 0 0 auto;
    }

    /* Content text (from Text.txt) */
    .tile p {
      margin: 0;
      font-size: var(--tileTextSize);
      line-height: 1.35;
      opacity: 0.92;
      white-space: pre-wrap;
      flex: 1 1 auto;              /* IMPORTANT */
      min-height: 0;               /* IMPORTANT */
      overflow: hidden;            /* IMPORTANT: enables fitting check */
    }

    /* Status / debug badge */
    .badge {
      position: fixed;
      right: clamp(12px, 1.2vw, 22px);
      bottom: clamp(10px, 1vw, 18px);
      font-size: clamp(11px, 0.9vw, 14px);
      opacity: 0.65;
      z-index: 9998;
    }

    /* Invisible fullscreen trigger */
    #fsBtn {
      position: fixed;
      inset: 0;
      background: transparent;
      border: none;
      cursor: pointer;
      z-index: 9999;
    }

    /* Small-screen fallback */
    @media (max-width: 900px) {
      body { overflow: auto; }
      .wrap { height: auto; }
      .grid {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        min-height: initial;
      }
      .tile { height: auto; overflow: visible; }
      .tile p { overflow: visible; }
    }
  </style>
</head>

<body>
  <!-- Press OK/Enter once on TV to request fullscreen (browser security requires a user gesture) -->
  <button id="fsBtn" aria-label="Enter fullscreen"></button>

  <div class="wrap">
    <!-- Page title -->
    <div id="pageTitle" class="top">What's On Tap</div>

    <!-- 3-column grid -->
    <div class="grid">
      <div class="tile" id="tile1">
        <h2 id="tap1" class="tap-label">Tap 1</h2>
        <img id="img1" class="img" alt="">
        <h2 id="t1" class="content-title"></h2>
        <p id="p1"></p>
      </div>

      <div class="tile" id="tile2">
        <h2 id="tap2" class="tap-label">Tap 2</h2>
        <img id="img2" class="img" alt="">
        <h2 id="t2" class="content-title"></h2>
        <p id="p2"></p>
      </div>

      <div class="tile" id="tile3">
        <h2 id="tap3" class="tap-label">Tap 3</h2>
        <img id="img3" class="img" alt="">
        <h2 id="t3" class="content-title"></h2>
        <p id="p3"></p>
      </div>
    </div>
  </div>

  <div id="status" class="badge"></div>

  <script>
    const REFRESH_MINUTES = 60;

    // Each folder contains: Image.png, Title.txt, Text.txt
    const taps = [
      { base: "tap1", tileId: "tile1", titleId: "t1", textId: "p1", imgId: "img1" },
      { base: "tap2", tileId: "tile2", titleId: "t2", textId: "p2", imgId: "img2" },
      { base: "tap3", tileId: "tile3", titleId: "t3", textId: "p3", imgId: "img3" }
    ];

    const statusEl = document.getElementById("status");
    const setStatus = (msg) => statusEl.textContent = msg;

    async function loadTap(tap) {
      const titleRes = await fetch(`/${tap.base}/Title.txt?v=${Date.now()}`, { cache: "no-store" });
      if (!titleRes.ok) throw new Error(`Missing ${tap.base}/Title.txt`);
      document.getElementById(tap.titleId).textContent = (await titleRes.text()).trim();

      const textRes = await fetch(`/${tap.base}/Text.txt?v=${Date.now()}`, { cache: "no-store" });
      if (!textRes.ok) throw new Error(`Missing ${tap.base}/Text.txt`);
      document.getElementById(tap.textId).textContent = (await textRes.text()).trim();

      const img = document.getElementById(tap.imgId);
      img.onerror = () => setStatus(`❌ Image failed: /${tap.base}/Image.png`);
      img.src = `/${tap.base}/Image.png`;
      await img.decode?.().catch(() => {});
    }

    // ===== Dynamic text fitting =====
    // Shrinks only: (1) content title and (2) body text. Does NOT shrink Tap 1/2/3 label.
    function fitTileText(tileEl, { minTitlePx = 16, minBodyPx = 12 } = {}) {
      const contentTitle = tileEl.querySelector("h2.content-title");
      const body = tileEl.querySelector("p");
      if (!contentTitle || !body) return;

      // Reset inline sizes so clamp() provides baseline
      contentTitle.style.fontSize = "";
      body.style.fontSize = "";

      const maxIter = 140;
      const stepPx = 1;

      const getPx = (el) => parseFloat(getComputedStyle(el).fontSize);

      let titleSize = getPx(contentTitle);
      let bodySize  = getPx(body);

      const bodyOverflows = () => body.scrollHeight > body.clientHeight + 1;

      if (!bodyOverflows()) return;

      for (let i = 0; i < maxIter; i++) {
        if (!bodyOverflows()) break;

        if (bodySize > minBodyPx) {
          bodySize -= stepPx;
          body.style.fontSize = bodySize + "px";
        } else if (titleSize > minTitlePx) {
          titleSize -= stepPx;
          contentTitle.style.fontSize = titleSize + "px";
        } else {
          break;
        }
      }
    }

    function fitAllTiles() {
      for (const tap of taps) {
        const tile = document.getElementById(tap.tileId);
        if (tile) fitTileText(tile, { minTitlePx: 16, minBodyPx: 12 });
      }
    }

    let resizeTimer = null;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(fitAllTiles, 200);
    });

    async function loadAll() {
      try {
        setStatus("Loading…");
        for (const tap of taps) await loadTap(tap);

        // Let layout settle before fitting (two frames is more reliable on PCs)
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            fitAllTiles();
            setStatus("Updated: " + new Date().toLocaleString());
          });
        });
      } catch (e) {
        setStatus("ERROR: " + (e?.message || e));
        console.error(e);
      }
    }

    loadAll();
    setInterval(loadAll, REFRESH_MINUTES * 60 * 1000);

    // ===== Fullscreen handling (requires user gesture) =====
    function requestFullscreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) el.requestFullscreen();
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    }

    document.getElementById("fsBtn").addEventListener("click", () => {
      requestFullscreen();
      document.getElementById("fsBtn").remove();
    });
  </script>
</body>
</html>
